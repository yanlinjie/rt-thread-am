#include <am.h>
#include <klib.h>
#include <rtthread.h>

rt_thread_t pcb = NULL;
// rt_thread_t current = NULL;  // å…¨å±€å˜é‡ï¼Œè®°å½•å½“å‰çº¿ç¨‹
static Context* ev_handler(Event e, Context *c) {
  switch (e.event) {
    case EVENT_YIELD:  {
      rt_thread_t cp = rt_thread_self(); 
      rt_ubase_t to = cp->user_data;
      c = *(Context**)to;
      // c->mepc += 4;
      printf(" next to = 0x%08x\n",  (unsigned int)to);
      printf(" event ID = %d\n", e.event);
      break;
    }
    default: printf("Unhandled event ID = %d\n", e.event); assert(0);
  }
  return c;
}
void __am_cte_init() {
  cte_init(ev_handler);
}


void rt_hw_context_switch_to(rt_ubase_t to) {
   pcb = rt_thread_self();
  rt_ubase_t user_data_replicator = pcb->user_data;
  rt_kprintf("[context_switch_to] before switch: pcb->user_data = 0x%08x\n", (unsigned long)pcb->user_data);
  pcb->user_data = to;
  rt_kprintf("[context_switch_to] switching to: pcb->user_data = 0x%08x\n", (unsigned long)pcb->user_data);
  yield();
  pcb->user_data = user_data_replicator;
  rt_kprintf("[context_switch_to] after switch: pcb->user_data = 0x%08x\n", (unsigned long)pcb->user_data);
}


void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to) {
   pcb = rt_thread_self();

  // æ‰“å°å½“å‰çº¿ç¨‹ç»“æ„ä½“æŒ‡é’ˆ
  // printf("[switch] rt_thread_self = %p\n", pcb);

  // æ‰“å°æ—§çš„ user_data å’Œæ–°è®¾ç½®çš„ to
  rt_ubase_t user_data_replicator = pcb->user_data;
  printf("[switch] prev user_data = 0x%08x, next to = 0x%08x\n", 
          (unsigned int)user_data_replicator, (unsigned int)to);

  // è®¾ç½®ç›®æ ‡çº¿ç¨‹çš„ä¸Šä¸‹æ–‡æŒ‡é’ˆ
  pcb->user_data = to;

  // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡åˆ° from
  *(Context **)from = pcb->sp;
  printf("[switch] saved current sp (context) to from = 0x%08x\n", (unsigned int)from);

  // è§¦å‘ yieldï¼Œåˆ‡æ¢çº¿ç¨‹
  printf("[switch] yield start...\n");
  yield();
  printf("[switch] yield end (returned back here)\n");

  // æ¢å¤åŸæ¥çš„ user_data
  pcb->user_data = user_data_replicator;
  printf("[switch] user_data restored to 0x%08x\n", (unsigned int)user_data_replicator);
  // rt_thread_t pcb = rt_thread_self();
  // // rt_ubase_t user_data_replicator = pcb->user_data;
  // // pcb->user_data = to;
  // // *(Context**)from = pcb->sp;
  // // yield();
  // // pcb->user_data = user_data_replicator;
  assert(0);
}



void rt_hw_context_switch_interrupt(void *context, rt_ubase_t from, rt_ubase_t to, struct rt_thread *to_thread) {
  assert(0);
}
extern void entry_wrapper();  // åœ¨æ±‡ç¼–ä¸­å®ç°
// æ„é€ çº¿ç¨‹ä¸Šä¸‹æ–‡
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) {
  // 1. å¯¹é½æ ˆåœ°å€ï¼ˆå‘ä¸‹å¯¹é½åˆ° uintptr_t è¾¹ç•Œï¼‰
  uintptr_t sp = ((uintptr_t)stack_addr) & ~(sizeof(uintptr_t) - 1);

  // 2. åˆ†é… Context ç»“æ„ä½“ç©ºé—´
  Context *ctx = (Context *)(sp - sizeof(Context));

  // 3. æ¸…ç©º
  memset(ctx, 0, sizeof(Context));

  // 4. è®¾ç½® initial PC ä¸º entry_wrapper
  ctx->mepc = (uintptr_t)entry_wrapper;

  // 5. è®¾ç½®åˆå§‹ mstatusï¼šMPP = 11 (Machine)ï¼ŒMPIE = 1
  ctx->mstatus = 0x1800;

  // 6. ä½¿ç”¨å¯„å­˜å™¨ä¼ å‚ï¼ša0 = parameter, a1 = tentry, a2 = texit
  ctx->gpr[10] = (uintptr_t)parameter;  // a0
  ctx->gpr[11] = (uintptr_t)tentry;     // a1
  ctx->gpr[12] = (uintptr_t)texit;      // a2
  // ğŸ” æ·»åŠ è°ƒè¯•ä¿¡æ¯
  // printf(">> stack_init: tentry = 0x%08x, texit = 0x%08x, stack = 0x%08x\n",
  //   (unsigned int)tentry, (unsigned int)texit, (unsigned int)stack_addr);
// printf(">> ctx->gpr[12] (texit) = 0x%08x\n", (unsigned int)ctx->gpr[12]);
  printf(">> stack_init: tentry = 0x%x, texit = 0x%x, stack = 0x%x\n", (unsigned int)tentry, (unsigned int)texit, (unsigned int)stack_addr);


  return (rt_uint8_t *)ctx;
}

// void debug_print_hex(uintptr_t val) {
//   rt_kprintf("[entry_wrapper] a2 (texit) = 0x%08x\n", (unsigned int)val);
// }

